JavaScript 的垃圾回收主要是通过 **可达性分析** （Reachability Analysis）来完成的，而非纯粹的引用计数法。具体的实现可能依赖于具体的 JavaScript 引擎（如 V8、SpiderMonkey 等），但一般来说可达性分析更常被使用。

### 可达性分析

在可达性分析的上下文中，基础的逻辑是从一些“根”变量开始，确定哪些变量是可达的。根变量通常是全局变量和当前执行上下文中的局部变量。如果一个对象可以从根变量通过引用链条被访问到，那么它就被认为是“可达的”并且不会被垃圾回收。

例如：

```javascript
function example() {
    let a = {name: "A"};  // 'a' 是根
    let b = {name: "B"};  // 'b' 是根

    a.child = b;  // 'b' 可通过 'a' 到达
    b.child = a;  // 'a' 可通过 'b' 到达
}  // 函数调用结束后，'a' 和 'b' 因为相互引用不会被垃圾回收
```

在这个例子中，尽管 `a` 和 `b` 在函数 `example` 执行完后离开了它们的执行上下文，但由于它们相互引用，它们不会被认为是垃圾。

### 引用计数法

虽然引用计数法在某些场景和语言中是一个有效的垃圾回收策略，但它有一个著名的问题：循环引用。当两个或多个对象相互引用时，即使它们没有任何活动引用，它们的引用计数也永远不会达到 0。

```javascript
function example() {
    let a = {};
    let b = {};

    a.child = b;
    b.child = a;
}
```

在这个例子中，即便 `a` 和 `b` 在 `example` 函数执行完后不再可访问，它们的引用计数也不会达到 0，因此在引用计数法的情况下它们不会被回收，导致内存泄露。

综上所述，现代的 JavaScript 引擎通常使用可达性分析作为其垃圾回收的主要方法。